# Project Context Dump - RISC-V Processor Development

**Session Date:** 2026-02-26  
**Project:** Bootable RISC-V RV32IMAZicsr Processor  
**Goal:** Build a physical processor capable of booting OpenSBI firmware

---

## PROJECT OVERVIEW

### Ultimate Goal
Create a complete RISC-V RV32IMAZicsr processor in SystemVerilog that can:
1. Execute all RV32I, M, A, and Zicsr instructions
2. Boot OpenSBI firmware in simulation
3. Run on a physical FPGA board
4. Eventually boot Linux

### Current Achievement Level
**Phase 4 Complete** (out of 8 phases total)
- We have a WORKING processor that executes assembly programs
- Successfully prints "Hello RISC-V!" to UART console
- All basic RV32I instructions functional
- 8 critical hardware bugs identified and fixed

---

## PROJECT STRUCTURE

### Directory Layout
```
/silicogenplayground/bootble-vm-riscv/
├── rtl/                     # 2,246 lines of SystemVerilog
│   ├── core/               # CPU core (637 lines in cpu_core.sv)
│   ├── bus/                # Simple bus arbiter
│   ├── peripherals/        # RAM and UART
│   └── soc/                # Top-level SoC integration
├── sim/                     # Simulation infrastructure
│   ├── testbenches/        # Verilator testbenches
│   └── waveforms/          # VCD output (in .gitignore)
├── sw/                      # Software test programs
│   └── tests/hello.S       # "Hello RISC-V!" assembly program
├── docs/                    # Microarchitecture documentation
├── build/                   # Compiled artifacts (in .gitignore)
├── .gitignore              # Build artifacts, waveforms excluded
├── Makefile                # Build system
├── README.md               # User documentation
├── BLOG_POST.md            # Technical deep-dive blog post
├── PROJECT_SPEC.md         # Complete technical specification
├── .silicogenrules         # Design methodology
├── TODO.md                 # This project's todo list
└── .context                # This file
```

---

## KEY TECHNICAL DECISIONS

### CPU Microarchitecture
**Type:** Multi-cycle, non-pipelined processor  
**Why:** Simplicity and debuggability. Pipelining adds enormous complexity (hazards, forwarding, branch prediction).

**State Machine (8 states):**
1. STATE_RESET - Initialize CPU
2. STATE_FETCH - Request instruction from bus
3. STATE_FETCH_WAIT - Wait for instruction memory response
4. STATE_DECODE - Decode instruction, read registers
5. STATE_EXECUTE - Perform ALU/branch operations
6. STATE_MEMORY - Request memory for load/store
7. STATE_MEMORY_WAIT - Wait for memory response
8. STATE_WRITEBACK - Update register file and PC

**Key Design Principle:** Values computed in one state must be LATCHED (saved in registers) to be used in later states. This was the source of multiple bugs!

### Memory Map
```
0x00000000 - 0x003FFFFF : RAM (4MB)
0x10000000 - 0x100000FF : UART 16550 (ns16550a compatible)
```

**Critical:** OpenSBI expects RAM to start at 0x00000000 with PC reset vector at 0x00000000.

### Module Architecture

**CPU Core (`rtl/core/cpu_core.sv` - 637 lines):**
- Instantiates all submodules
- Implements state machine
- Manages control signals
- Handles PC updates

**Submodules:**
- `register_file.sv` - 32 x 32-bit registers, x0 hardwired to zero
- `alu.sv` - All RV32I arithmetic/logical operations
- `muldiv.sv` - Multiply/divide unit (multi-cycle)
- `decoder.sv` - Instruction decoder, immediate extraction
- `csr_file.sv` - Control/Status registers for privilege modes

**System Integration:**
- `simple_bus.sv` - Address-based routing between CPU and peripherals
- `ram.sv` - 4MB RAM with $readmemh initialization
- `uart_16550.sv` - UART controller (transmit working, receive stubbed)
- `riscv_soc.sv` - Top-level integration

---

## THE 8 BUGS WE FIXED

### Bug #1: Bus Request Signals Not Held During Wait States
**Problem:** `ibus_req` went LOW during FETCH_WAIT, causing bus to never respond.  
**Fix:** Keep request HIGH during both FETCH and FETCH_WAIT states.
```systemverilog
ibus_req = (state == STATE_FETCH) || (state == STATE_FETCH_WAIT);
```

### Bug #2: Register Write Enable Not Latched
**Problem:** Control signal from DECODE state was gone by WRITEBACK.  
**Fix:** Added `reg_write_enable_latched` register, saved in EXECUTE state.

### Bug #3: PC Updated Incorrectly After Branches
**Problem:** PC always advanced by 4, even after jumps.  
**Fix:** Only increment PC for sequential instructions:
```systemverilog
if (!is_jal && !is_jalr && !(is_branch && branch_taken)) begin
    next_pc = pc + 4;
end
```

### Bug #4: Register Write Data Source Not Latched
**Problem:** Writeback mux selector was stale by WRITEBACK state.  
**Fix:** Added `reg_write_source_latched`, saved in EXECUTE.

### Bug #5: Load Byte/Halfword Extraction Incorrect
**Problem:** `lbu` instruction returned full 32-bit word instead of extracting correct byte.  
**Fix:** Added logic to:
- Latch memory width and sign-extension control
- Extract correct byte/halfword based on address offset
- Perform sign extension if needed

### Bug #6: Memory Address Used Wrong ALU Result
**Problem:** MEMORY state used current `alu_result` instead of latched value.  
**Fix:** Changed to use `alu_result_reg` (saved from EXECUTE).

### Bug #7: UART Byte Addressing
**Problem:** UART decoded `addr[4:2]` instead of `addr[2:0]`, wrong for byte access.  
**Fix:** Changed to byte addressing.

### Bug #8: Store Instructions Never Advanced PC (THE BIG ONE)
**Problem:** Stores skipped WRITEBACK state, but PC update only happened in WRITEBACK.  
**Symptom:** CPU printed 'H' infinitely, stuck at same PC.  
**Fix:** Made stores go through WRITEBACK too (even though they don't write registers).
```systemverilog
// OLD: Stores went directly to FETCH
// NEW: Both loads and stores go through WRITEBACK
next_state = STATE_WRITEBACK;
```

---

## CURRENT WORKING STATUS

### What Works (Verified)
- ✓ All RV32I base instructions (40+ instructions)
- ✓ Loads: LB, LBU, LH, LHU, LW with correct byte extraction
- ✓ Stores: SB, SH, SW with correct byte addressing
- ✓ Branches: BEQ, BNE, BLT, BGE, BLTU, BGEU
- ✓ Jumps: JAL, JALR with correct PC calculation
- ✓ Immediate operations: ADDI, SLTI, ANDI, ORI, XORI, SLLI, SRLI, SRAI
- ✓ Register operations: ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, SLT, SLTU
- ✓ Upper immediate: LUI, AUIPC
- ✓ Memory-mapped I/O: UART reads/writes working
- ✓ State machine: All transitions correct
- ✓ PC advancement: Sequential, branches, jumps all correct

### What's Implemented But Not Fully Tested
- M Extension: Multiply/divide hardware exists but needs comprehensive testing
- CSR Instructions: Basic implementation exists but needs trap handling
- A Extension: Not yet implemented

### Test Program Success
The `sw/tests/hello.S` program successfully:
1. Sets up stack pointer
2. Loads string address
3. Calls print function
4. Loops through string characters
5. Waits for UART ready
6. Writes each character to UART
7. Increments pointer and loops
8. Returns when null terminator found

**Output:** "Hello RISC-V!\n" printed character by character to UART console.

---

## SIMULATION INFRASTRUCTURE

### Build Process
```bash
# 1. Build software (assembly to hex)
make sw
  → Assembles hello.S to ELF
  → Converts to binary
  → Converts to Verilog hex format (build/hello.hex)
  → Generates disassembly (build/hello.dump)

# 2. Build hardware simulation
make sim
  → Verilator compiles SystemVerilog to C++
  → Compiles C++ to native executable
  → Output: build/verilator/Vtb_soc

# 3. Run simulation
./build/verilator/Vtb_soc
  → Loads hello.hex into RAM
  → Simulates at 50 MHz clock
  → Captures UART output
  → Runs for 100ms simulated time
```

### Simulation Features
- **Clock:** 50 MHz (20ns period)
- **UART Baud:** 115200 (434 clock cycles per bit)
- **Tracing:** Detailed PC, state, register tracking
- **Waveforms:** VCD output for GTKWave viewing
- **Auto-checking:** Testbench monitors for success/failure

### Key Simulation Files
- `sim/testbenches/tb_soc.sv` - SystemVerilog testbench
  - Instantiates SoC
  - Generates clock and reset
  - Monitors UART TX line (bit-level simulation)
  - Prints debug information
- `sim/sim_main.cpp` - Verilator C++ wrapper
  - Main loop with timing
  - VCD waveform dumping
  - Console output

---

## TOOLS & ENVIRONMENT

### Installed Tools
| Tool | Version | Purpose |
|------|---------|---------|
| Verilator | 5.020 | SystemVerilog simulation |
| riscv64-linux-gnu-gcc | 13.3.0 | RISC-V cross-compiler |
| GTKWave | 3.3.116 | Waveform viewer |
| Make | 4.3 | Build automation |
| Git | 2.43.0 | Version control |
| Python 3 | 3.12.3 | Scripting |

### Build Commands Reference
```bash
# Clean
make clean              # Remove all build artifacts

# Software
make sw                 # Build assembly test program

# Hardware
make sim                # Compile Verilator simulation

# All-in-one
make                    # Builds sw and sim

# Run
./build/verilator/Vtb_soc

# Debug
gtkwave sim/waveforms/tb_soc.vcd
cat build/hello.dump    # View disassembly
```

---

## GIT REPOSITORY STATUS

### Repository Info
- **Remote:** https://github.com/Silicogen-Labs/silicogen-proj-bootable-riscv-opensbi.git
- **Branch:** main

### Important Files in .gitignore
```
build/                  # All compiled artifacts
sim/waveforms/*.vcd     # Large waveform files (945MB!)
sim/waveforms/*.fst
*.o, *.elf, *.bin       # Intermediate files
```

### Recent Git Operations
1. Removed large VCD file (945MB) from Git history
2. Added comprehensive .gitignore
3. Removed all build artifacts from tracking
4. Updated README.md and BLOG_POST.md
5. Removed emojis from markdown files (per user request)

### How We Fixed Git Large File Issue
The VCD waveform file was 945MB, exceeding GitHub's 100MB limit. We:
1. Added `sim/waveforms/*.vcd` to .gitignore
2. Removed the file from Git tracking: `git rm --cached sim/waveforms/tb_soc.vcd`
3. Committed .gitignore changes
4. Successfully pushed to GitHub

---

## INSTRUCTION SET STATUS

### RV32I Base (Complete ✓)
```
Arithmetic:    ADD, ADDI, SUB
Logical:       AND, ANDI, OR, ORI, XOR, XORI
Shift:         SLL, SLLI, SRL, SRLI, SRA, SRAI
Compare:       SLT, SLTI, SLTU, SLTIU
Upper Imm:     LUI, AUIPC
Load:          LB, LH, LW, LBU, LHU
Store:         SB, SH, SW
Branch:        BEQ, BNE, BLT, BGE, BLTU, BGEU
Jump:          JAL, JALR
System:        ECALL, EBREAK (basic, needs trap handling)
Fence:         FENCE, FENCE.I (stubbed, not tested)
```

### M Extension (Implemented, Needs Testing)
```
Multiply:      MUL, MULH, MULHSU, MULHU
Divide:        DIV, DIVU, REM, REMU
```
**Status:** Hardware exists in `muldiv.sv` but not comprehensively verified.

### A Extension (Not Implemented)
```
Load-Reserved:   LR.W
Store-Cond:      SC.W
Atomic Ops:      AMOSWAP.W, AMOADD.W, AMOAND.W, AMOOR.W, AMOXOR.W
                 AMOMIN.W, AMOMAX.W, AMOMINU.W, AMOMAXU.W
```
**Status:** Planned for Phase 5.

### Zicsr Extension (Partial Implementation)
```
CSR Access:    CSRRW, CSRRS, CSRRC, CSRRWI, CSRRSI, CSRRCI
```
**Status:** Basic CSR file exists, but trap handling incomplete. Needed for OpenSBI.

---

## CSR (CONTROL/STATUS REGISTERS) STATUS

### Implemented (Basic)
```
misa      (0x301) - ISA and extensions identifier
mhartid   (0xF14) - Hardware thread ID
mstatus   (0x300) - Machine status (partial)
mtvec     (0x305) - Trap vector base
mepc      (0x341) - Exception PC
mcause    (0x342) - Trap cause
mtval     (0x343) - Trap value
```

### Not Yet Implemented
```
mie       (0x304) - Interrupt enable
mip       (0x344) - Interrupt pending
mscratch  (0x340) - Scratch register
mcycle    (0xB00) - Cycle counter
minstret  (0xB02) - Instruction counter
mcycleh   (0xB80) - Cycle counter high (RV32)
minstreth (0xB82) - Instruction counter high (RV32)
```

### Required for OpenSBI
All of the above CSRs must be fully implemented for OpenSBI to boot successfully.

---

## MEMORY ORGANIZATION

### RAM (4MB at 0x00000000)
- **Size:** 4,194,304 bytes (1,048,576 words)
- **Implementation:** `rtl/peripherals/ram.sv`
- **Initialization:** Via `$readmemh(MEM_INIT_FILE)`
- **Access:** Word-aligned (32-bit), but supports byte/halfword via byte enable
- **Latency:** 1 cycle (ready signal HIGH immediately)

### UART (0x10000000 - 0x100000FF)
- **Type:** 16550A compatible
- **Implementation:** `rtl/peripherals/uart_16550.sv`
- **Registers:**
  - 0x00: THR (Transmit Holding Register) / RHR (Receive Holding Register)
  - 0x05: LSR (Line Status Register) - bit 5 = TX empty
- **Baud Rate:** 115200 (simulated)
- **Status:** Transmit working, receive stubbed

### Address Decoding Logic
```systemverilog
// In simple_bus.sv
if (addr >= 32'h00000000 && addr < 32'h00400000)
    → Route to RAM
else if (addr >= 32'h10000000 && addr < 32'h10000100)
    → Route to UART
else
    → Bus error
```

---

## DETAILED FILE DESCRIPTIONS

### Core RTL Files

**cpu_core.sv (637 lines) - The Heart**
- State machine implementation
- All control signal generation
- PC update logic
- Instantiates: register_file, alu, muldiv, decoder, csr_file
- Key insight: Extensive use of latched signals (values saved from previous states)

**register_file.sv (58 lines)**
- 32 registers x 32 bits
- x0 always reads as zero
- Dual read ports (rs1, rs2)
- Single write port (rd)
- Asynchronous read, synchronous write

**alu.sv (89 lines)**
- All RV32I arithmetic and logical operations
- Combinational logic (single cycle)
- Outputs: result, zero flag, negative flag

**muldiv.sv (260 lines)**
- Multi-cycle multiply unit
- Iterative divide unit
- State machine for operation sequencing
- 32 cycles for divide (worst case)

**decoder.sv (256 lines)**
- Parses 32-bit instruction word
- Extracts opcode, funct3, funct7, rs1, rs2, rd
- Generates immediate values with correct sign extension
- Outputs control signals (is_load, is_store, is_branch, etc.)

**csr_file.sv (291 lines)**
- Implements CSR read/write operations
- Contains all CSR registers
- Handles CSRRW, CSRRS, CSRRC instructions
- Trap handling logic (partial)

### Bus & Peripherals

**simple_bus.sv (169 lines)**
- Single master (CPU), multiple slaves
- Address-based routing
- Valid/ready handshake protocol
- Combinational routing logic

**ram.sv (72 lines)**
- Parameterized size and init file
- Synchronous read/write
- Supports byte enables (wstrb signal)
- Uses `$readmemh` for program loading

**uart_16550.sv (186 lines)**
- Simplified 16550A implementation
- Memory-mapped registers
- Transmit buffer and status
- Clock divider for baud rate (stubbed in simulation)

### Top-Level

**riscv_soc.sv (131 lines)**
- Instantiates: cpu_core, simple_bus, ram, uart
- Connects clock and reset to all modules
- Wires bus signals between components
- Parameter: MEM_INIT_FILE for program loading

---

## TESTING METHODOLOGY

### Current Test: hello.S
**Location:** `sw/tests/hello.S`
**Purpose:** Verify basic CPU functionality end-to-end

**What it tests:**
- Immediate loads (LUI, LI pseudo-instruction)
- Function calls (JAL)
- Load byte unsigned (LBU)
- Branch if equal zero (BEQZ)
- Store byte (SB)
- Add immediate (ADDI)
- Unconditional jump (J pseudo-instruction)
- Return (RET pseudo-instruction)
- UART I/O
- Memory addressing

**Test Flow:**
```
1. _start:
   - Set stack pointer (LUI, ORI)
   - Load string address into a0
   - Call print_string
   - Infinite loop at done

2. print_string:
   - Load UART base address
   - Loop: load character, check if zero, exit if done
   - Wait for UART TX ready
   - Write character
   - Increment pointer
   - Repeat

3. String data at 0xFC: "Hello RISC-V!\n\0"
```

### Future Tests Needed
1. **Arithmetic Test Suite**
   - All ALU operations with edge cases
   - Overflow, underflow, zero cases
   
2. **Memory Test Suite**
   - Aligned and unaligned accesses
   - Byte, halfword, word operations
   - Load/store with various offsets

3. **Branch Test Suite**
   - All branch conditions
   - Forward and backward branches
   - Branch delay slots (N/A for non-pipelined)

4. **Multiply/Divide Tests**
   - All variants: MUL, MULH, MULHSU, MULHU
   - DIV, DIVU, REM, REMU
   - Edge cases: division by zero, MIN_INT / -1

5. **CSR Tests**
   - Read/write all CSRs
   - Privilege level checks
   - Trap handling

6. **Interrupt Tests**
   - Timer interrupts
   - External interrupts
   - Interrupt masking and nesting

---

## DEBUGGING TECHNIQUES USED

### Signal Tracing in Testbench
We added detailed $display statements to track:
- CPU state transitions
- PC values at each state
- Register writes (destination, data, source)
- Memory accesses (address, data, read/write)
- UART transactions

### Waveform Analysis with GTKWave
Key signals to observe:
```
tb_soc.dut.u_cpu_core.state
tb_soc.dut.u_cpu_core.pc
tb_soc.dut.u_cpu_core.instruction
tb_soc.dut.u_cpu_core.next_pc
tb_soc.dut.u_cpu_core.alu_result
tb_soc.dut.u_cpu_core.alu_result_reg
tb_soc.dut.u_cpu_core.reg_write_enable
tb_soc.dut.u_cpu_core.reg_write_enable_latched
tb_soc.dut.u_cpu_core.u_register_file.registers[10]  # a0
tb_soc.dut.u_simple_bus.dbus_addr
tb_soc.dut.u_uart.uart_tx
```

### Disassembly Cross-Reference
Always have `build/hello.dump` open to verify:
- Expected instruction at current PC
- Correct immediate values decoded
- Proper register assignments
- Jump/branch target addresses

### Iterative Debug Process
1. Run simulation
2. Identify unexpected behavior from console output
3. Note the PC and timestamp where issue occurs
4. Open VCD in GTKWave, navigate to that time
5. Examine all signals leading up to issue
6. Form hypothesis about root cause
7. Check RTL code at suspected location
8. Fix bug
9. Rerun simulation
10. Verify fix, repeat if needed

---

## VERILATOR USAGE NOTES

### Compilation Warnings (Safe to Ignore)
- PINCONNECTEMPTY: Unused decoder outputs (is_r_type, etc.)
- TIMESCALEMOD: Missing timescale in modules (not critical)
- UNUSEDSIGNAL: Signals defined but not used (code cleanup needed)
- UNSIGNED: Comparison with 0x00000000 always true (style issue)

### Performance Characteristics
- **Compilation Time:** ~10 seconds on modern laptop
- **Simulation Speed:** ~1M cycles/second (depends on hardware)
- **Memory Usage:** ~200MB for our design

### Verilator Command
```bash
verilator --cc --exe --build --trace --timing \
  -Wall -Wno-fatal \
  --top-module tb_soc \
  -Irtl/core -Irtl/bus -Irtl/peripherals -Irtl/soc \
  --Mdir build/verilator \
  rtl/**/*.sv sim/testbenches/tb_soc.sv sim/sim_main.cpp
```

---

## OPENSBI REQUIREMENTS (PHASE 7 PREPARATION)

### What OpenSBI Expects

1. **CPU starts in M-mode** (Machine mode, most privileged)
2. **PC starts at 0x00000000** (or configured address)
3. **All CSRs readable/writable** according to spec
4. **Trap handling works** (exceptions and interrupts)
5. **Timer interrupts work** (mtime, mtimecmp registers)
6. **UART console functional** (ns16550a at expected address)
7. **Device tree in memory** (pointer passed in register a1)

### Device Tree Structure (To Be Created)
```dts
/dts-v1/;
/ {
    #address-cells = <1>;
    #size-cells = <1>;
    compatible = "bootble,riscv-soc";
    
    cpus {
        cpu@0 {
            device_type = "cpu";
            compatible = "riscv";
            riscv,isa = "rv32ima_zicsr";
        };
    };
    
    memory@0 {
        device_type = "memory";
        reg = <0x0 0x400000>;  // 4MB
    };
    
    soc {
        uart@10000000 {
            compatible = "ns16550a";
            reg = <0x10000000 0x100>;
            clock-frequency = <50000000>;
        };
    };
    
    chosen {
        stdout-path = "uart@10000000";
    };
};
```

### OpenSBI Boot Sequence (What We'll See)
1. OpenSBI prints banner
2. Platform detection
3. HART (hardware thread) initialization
4. Timer setup
5. Console initialization
6. Jump to next boot stage (payload or kernel)

### Expected Console Output
```
OpenSBI v1.x
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 ...
Platform Name: bootble,riscv-soc
Boot HART ID: 0
Boot HART ISA: rv32ima_zicsr
...
```

---

## FPGA TARGETS (PHASE 8)

### Recommended Boards

**Option 1: Xilinx Artix-7 Boards**
- Arty A7-35T (~$129)
- Nexys A7 (~$300)
- Pros: Good tool support (Vivado), lots of resources
- Cons: Proprietary tools, larger/more expensive

**Option 2: Lattice iCE40 Boards**
- iCEBreaker (~$100)
- ULX3S (~$150)
- Pros: Open-source toolchain (yosys, nextpnr), cheaper
- Cons: Smaller devices, may be tight on resources

**Option 3: Intel Cyclone V**
- DE10-Lite (~$85)
- Pros: Good price/performance
- Cons: Quartus tools can be heavy

### Resource Estimates
```
Logic Elements: 10K-15K LUTs (depends on optimizations)
Block RAM: 128KB minimum (32KB for code, rest for data)
Clock Speed Target: 50-100 MHz
I/O Pins Needed:
  - 1 for UART TX
  - 1 for UART RX (optional)
  - 1 for reset button
  - 1 for clock input (or use PLL)
  - 4-8 for status LEDs
```

---

## CRITICAL DESIGN PATTERNS LEARNED

### Pattern 1: Signal Latching in Multi-Cycle Design
**Problem:** Values computed in cycle N needed in cycle N+M.  
**Solution:** Use intermediate registers to save values.
```systemverilog
// In EXECUTE state:
always_ff @(posedge clk) begin
    if (state == STATE_EXECUTE) begin
        alu_result_reg <= alu_result;
        reg_write_enable_latched <= reg_write_enable;
        reg_write_source_latched <= reg_write_source;
    end
end

// In WRITEBACK state, use latched values:
assign rf_rd_data = (reg_write_source_latched == 0) ? alu_result_reg :
                    (reg_write_source_latched == 1) ? mem_data_processed :
                    (reg_write_source_latched == 2) ? pc_plus_4 : 32'h0;
```

### Pattern 2: Request-Acknowledge Handshake
**Problem:** Memory requests need to wait for response.  
**Solution:** Hold request HIGH until acknowledge received.
```systemverilog
// Request must stay HIGH during both request and wait
assign ibus_req = (state == STATE_FETCH) || (state == STATE_FETCH_WAIT);

// State machine waits for ready
STATE_FETCH_WAIT: begin
    if (ibus_ready) begin
        instruction <= ibus_rdata;
        next_state = STATE_DECODE;
    end
end
```

### Pattern 3: PC Update Centralization
**Problem:** PC updates scattered across multiple states.  
**Solution:** Single always_comb block for next_pc calculation.
```systemverilog
always_comb begin
    next_pc = pc;  // Default: hold
    
    case (state)
        STATE_EXECUTE: begin
            if (is_jal) next_pc = pc + imm;
            else if (is_jalr) next_pc = (rs1_data + imm) & ~1;
            else if (is_branch && branch_taken) next_pc = pc + imm;
        end
        
        STATE_WRITEBACK: begin
            // Only advance for sequential instructions
            if (!is_jal && !is_jalr && !(is_branch && branch_taken))
                next_pc = pc + 4;
        end
    endcase
end
```

### Pattern 4: Byte-Aligned Memory Access
**Problem:** CPU uses word addresses, peripherals need byte addresses.  
**Solution:** Extract correct byte/halfword based on low address bits.
```systemverilog
// For LBU (load byte unsigned):
logic [1:0] offset;
logic [7:0] byte_data;

offset = alu_result_reg[1:0];  // Which byte in word?

case (offset)
    2'b00: byte_data = mem_data_reg[7:0];
    2'b01: byte_data = mem_data_reg[15:8];
    2'b10: byte_data = mem_data_reg[23:16];
    2'b11: byte_data = mem_data_reg[31:24];
endcase

result = {24'b0, byte_data};  // Zero-extend for unsigned
```

---

## SESSION HANDOFF CHECKLIST

When resuming this project in a new session:

### Files to Review First
1. **TODO.md** (this file's sibling) - What needs to be done next
2. **.context** (this file) - Full project understanding
3. **README.md** - User-facing documentation
4. **PROJECT_SPEC.md** - Technical specification
5. **BLOG_POST.md** - Detailed journey documentation

### State Verification Commands
```bash
# Check git status
git status
git log --oneline -10

# Verify build system works
make clean
make sw
make sim

# Run simulation
./build/verilator/Vtb_soc

# Expected: Should print "Hello RISC-V!" character by character
```

### If Simulation Doesn't Work
1. Check if `build/hello.hex` exists (run `make sw`)
2. Check if `build/verilator/Vtb_soc` exists (run `make sim`)
3. Look for error messages in console
4. Check waveforms: `gtkwave sim/waveforms/tb_soc.vcd`

### Common "Resume Session" Issues
- **Issue:** "Can't find verilator"
  - **Fix:** Check if Verilator installed: `verilator --version`
  
- **Issue:** "Can't find riscv64-linux-gnu-gcc"
  - **Fix:** Check toolchain: `riscv64-linux-gnu-gcc --version`
  
- **Issue:** "Permission denied" on Vtb_soc
  - **Fix:** `chmod +x build/verilator/Vtb_soc`

---

## NEXT SESSION IMMEDIATE GOALS

### Priority 1: M-Extension Testing
Write comprehensive tests for multiply/divide:
```assembly
# Test MUL instruction
test_mul:
    li t0, 100
    li t1, 200
    mul t2, t0, t1      # t2 should be 20000
    li t3, 20000
    bne t2, t3, fail
    # ... more tests
```

### Priority 2: A-Extension Implementation
Start with simplest atomic operation:
1. Implement LR.W (Load Reserved)
2. Implement SC.W (Store Conditional)
3. Test basic LR/SC sequence
4. Then implement AMO* operations

### Priority 3: Trap Handling
1. Implement exception detection (illegal instruction, misalignment)
2. Update mepc, mcause, mtval on trap
3. Jump to mtvec on trap
4. Test ECALL and EBREAK

---

## IMPORTANT NOTES

### Things That Surprised Us
1. **Latching is HARD:** Took 4 bugs before pattern became clear
2. **Store PC bug was subtle:** Took hours to find
3. **UART byte addressing:** Easy to get wrong, hard to debug
4. **Verilator is FAST:** Millions of cycles in seconds
5. **Waveforms are essential:** Can't debug without them

### Things That Worked Well
1. **Incremental testing:** Start simple (hello world), build up
2. **Good testbench logging:** Detailed $display statements saved us
3. **Disassembly cross-reference:** Always know what SHOULD happen
4. **Git for version control:** Could revert bad changes

### Lessons for Future Phases
1. **Test early, test often:** Don't write 1000 lines before testing
2. **One bug at a time:** Fix, verify, commit, repeat
3. **Document as you go:** Future you will thank present you
4. **Use TODO.md:** Track what's done, what's next
5. **Keep .context updated:** Essential for long projects

---

## ADDITIONAL RESOURCES

### Our Documentation
- `docs/cpu_state_machine.md` - State machine diagram
- `docs/datapath.md` - Data flow paths
- `docs/control_signals.md` - All control signals defined
- `docs/memory_map.md` - Address space layout
- `docs/csr_requirements.md` - CSR specifications

### External References
- RISC-V ISA Manual: https://riscv.org/specifications/
- RISC-V Privileged Spec: https://riscv.org/specifications/privileged-isa/
- OpenSBI Repo: https://github.com/riscv-software-src/opensbi
- Verilator Manual: https://verilator.org/guide/latest/

### Inspirational Article
- Uros Popovic's "RISC-V SBI and the full boot process"
- https://popovicu.com/posts/risc-v-sbi-and-full-boot-process/

---

## FINAL THOUGHTS

This project demonstrates that building a real processor from scratch is absolutely achievable with:
- Good planning (microarchitecture first!)
- Incremental testing (start simple, build up)
- Systematic debugging (waveforms, traces, cross-reference)
- Persistence (we fixed 8 bugs to get here)

We're now 50% through the journey (Phase 4 of 8). The processor WORKS and executes real code. The next phases will add more features and eventually boot real firmware.

**Most Important:** This is a learning project. Every bug taught us something. Every fix made us better hardware designers. Document everything, test thoroughly, and enjoy the process!

---

**END OF CONTEXT DUMP**

*This file should be updated at major milestones or when significant design decisions are made.*
