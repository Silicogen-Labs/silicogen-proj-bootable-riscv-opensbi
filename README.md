# RISC-V RV32IMAZicsr Processor - Bootable VM Hardware Implementation

A complete, working RISC-V processor designed from scratch in SystemVerilog, with the ultimate goal of booting OpenSBI firmware on an FPGA.

---

## Project Vision

This project aims to create a **physical hardware implementation** of a RISC-V processor capable of booting real-world firmware. We're building a minimal but complete System-on-a-Chip (SoC) that can run OpenSBI (the RISC-V Supervisor Binary Interface), following the same boot process described in production RISC-V systems.

**Current Status: Phase 4 Complete **  
We have a working processor that executes assembly programs and prints to a UART console. Next up: completing the M/A extensions, implementing trap handling, and finally booting OpenSBI firmware.

---

## Project Features

### Currently Implemented

-   **RV32I Base Instruction Set:** Full support for the 40+ base integer instructions (arithmetic, logical, load/store, branches, jumps)
-   **Multi-Cycle CPU Core:** A simple, debuggable 8-state processor (RESET, FETCH, FETCH_WAIT, DECODE, EXECUTE, MEMORY, MEMORY_WAIT, WRITEBACK)
-   **Memory-Mapped System-on-a-Chip:**
    -   4MB RAM (0x00000000 - 0x003FFFFF)
    -   UART 16550 peripheral (0x10000000 - 0x100000FF)
    -   Simple bus arbiter for routing memory requests
-   **Comprehensive Simulation Environment:**
    -   Verilator-based high-speed simulation
    -   Detailed signal tracing and waveform generation
    -   Self-checking testbenches
-   **Working Test Program:** "Hello, RISC-V!" assembly program that demonstrates loads, stores, branches, and I/O

### In Progress / Planned

-   **M Extension:** Integer multiplication and division (hardware implemented, needs verification)
-   **A Extension:** Atomic memory operations (`LR`, `SC`, `AMO*`)
-   **Zicsr Extension:** Control and Status Registers for privilege levels and trap handling
-   **Trap Handling:** Exceptions, interrupts, and privilege mode transitions
-   **OpenSBI Firmware:** Boot the official RISC-V firmware
-   **FPGA Implementation:** Synthesize and run on physical hardware

---

## Directory Structure

```
bootble-vm-riscv/
├── build/                  # Compiled artifacts (generated by make)
│   ├── hello.elf          # Compiled test program
│   ├── hello.hex          # Memory initialization file
│   └── verilator/         # Verilator simulation executable
├── docs/                   # Microarchitecture documentation
│   ├── cpu_state_machine.md
│   ├── datapath.md
│   ├── control_signals.md
│   ├── memory_map.md
│   └── csr_requirements.md
├── rtl/                    # SystemVerilog RTL source (2,246 lines)
│   ├── core/              # CPU core modules
│   │   ├── cpu_core.sv         # Main CPU (637 lines)
│   │   ├── alu.sv              # Arithmetic/Logic Unit
│   │   ├── muldiv.sv           # Multiply/Divide unit
│   │   ├── decoder.sv          # Instruction decoder
│   │   ├── csr_file.sv         # Control/Status registers
│   │   └── register_file.sv    # 32 general-purpose registers
│   ├── bus/               # System interconnect
│   │   └── simple_bus.sv       # Memory-mapped bus arbiter
│   ├── peripherals/       # I/O devices
│   │   ├── ram.sv              # Main memory controller
│   │   └── uart_16550.sv       # Serial console (ns16550a compatible)
│   └── soc/               # Top-level integration
│       └── riscv_soc.sv        # Complete SoC
├── sim/                    # Simulation infrastructure
│   ├── testbenches/
│   │   └── tb_soc.sv          # SystemVerilog testbench
│   ├── sim_main.cpp           # Verilator C++ wrapper
│   └── waveforms/             # VCD output directory (generated)
├── sw/                     # Software to run on the processor
│   └── tests/
│       └── hello.S            # "Hello, RISC-V!" assembly test
├── .silicogenrules         # Project methodology and workflow
├── PROJECT_SPEC.md         # Detailed technical specification
├── BLOG_POST.md            # Deep-dive blog post on the journey
├── Makefile                # Build system
└── README.md               # This file
```

---

## Prerequisites

Before you begin, ensure you have the following tools installed:

| Tool | Purpose | Installation |
|------|---------|--------------|
| **Verilator** | High-performance SystemVerilog simulator | `apt install verilator` (v5.020+) |
| **RISC-V GNU Toolchain** | Cross-compiler for RISC-V binaries | `apt install gcc-riscv64-linux-gnu` |
| **Make** | Build automation | Usually pre-installed |
| **GTKWave** | Waveform viewer (optional) | `apt install gtkwave` |

### Verify Installation

```bash
verilator --version       # Should show v5.020 or later
riscv64-linux-gnu-gcc --version
make --version
```

---

## Quick Start

Build and run the processor simulation in three commands:

```bash
# Clean any previous builds
make clean

# Build the software and hardware
make sw && make sim

# Run the simulation
./build/verilator/Vtb_soc
```

---

## Detailed Build Instructions

### Step 1: Clean the Project

Remove all previously compiled files:

```bash
make clean
```

This deletes:
- `build/` directory (ELF files, HEX files, Verilator objects)
- `sim/waveforms/*.vcd` (waveform dumps)

### Step 2: Build the Software

Compile the test program from assembly to machine code:

```bash
make sw
```

This runs:
1. `riscv64-linux-gnu-gcc` - Assembles `sw/tests/hello.S` into an ELF binary
2. `riscv64-linux-gnu-objcopy` - Converts ELF to raw binary
3. `od` + `awk` - Converts binary to Verilog hex format
4. `riscv64-linux-gnu-objdump` - Generates disassembly for debugging

**Output files:**
- `build/hello.elf` - Executable binary
- `build/hello.hex` - Memory initialization file (loaded into simulated RAM)
- `build/hello.dump` - Disassembly listing

### Step 3: Build the Hardware Simulation

Compile the SystemVerilog design with Verilator:

```bash
make sim
```

This invokes Verilator to:
1. Parse all `.sv` files in `rtl/`
2. Generate optimized C++ code
3. Compile to a native executable
4. Link with the testbench (`sim/sim_main.cpp`)

**Output:**
- `build/verilator/Vtb_soc` - Simulation executable

**Note:** You may see warnings about unused signals or timescale mismatches. These are safe to ignore for now.

### Step 4: Run the Simulation

Execute the compiled simulator:

```bash
./build/verilator/Vtb_soc
```

**What happens:**
1. The testbench instantiates the SoC
2. RAM is initialized with `build/hello.hex`
3. Clock generation starts (50 MHz)
4. The CPU resets and begins fetching instructions from address 0x00000000
5. The program executes, writing characters to the UART
6. The testbench captures UART output and prints it to the console
7. After ~100ms of simulated time, the simulation completes

---

## Expected Output

A successful simulation produces output like this:

```
=== Starting RISC-V SoC Verilator Simulation ===
=== Starting RISC-V SoC Simulation ===
Time: 0
Reset released at time 190000
Waiting for UART output...
[390000] *** REG x10 (a0) <= 0x000000fc (PC=0x00000004)

=== Tracing print_loop execution ===
Expected flow: 0x14->0x18->0x1C->0x20->0x24->0x28->0x2C->0x30->0x14 (loop)
[610000] FETCH     PC=0x14 | a0=0x000000fc t0=0x00000000 t1=0x00000000
[670000] EXECUTE   PC=0x14 | alu_result=0x000000fc branch_taken=0 is_jal=0 is_jalr=0
[730000] WRITEBACK PC=0x14 | rd=x5 we=1 data=0x00000048 next_pc=0x00000018
[1270000] UART WRITE: addr=0x10000000 data=0x48 'H' (PC=0x00000028)
[2190000] UART WRITE: addr=0x10000000 data=0x65 'e' (PC=0x00000028)
[3110000] UART WRITE: addr=0x10000000 data=0x6c 'l' (PC=0x00000028)
[4030000] UART WRITE: addr=0x10000000 data=0x6c 'l' (PC=0x00000028)
[4950000] UART WRITE: addr=0x10000000 data=0x6f 'o' (PC=0x00000028)
[5870000] UART WRITE: addr=0x10000000 data=0x20 ' ' (PC=0x00000028)
[6790000] UART WRITE: addr=0x10000000 data=0x52 'R' (PC=0x00000028)
[7710000] UART WRITE: addr=0x10000000 data=0x49 'I' (PC=0x00000028)
[8630000] UART WRITE: addr=0x10000000 data=0x53 'S' (PC=0x00000028)
[9550000] UART WRITE: addr=0x10000000 data=0x43 'C' (PC=0x00000028)
[10470000] UART WRITE: addr=0x10000000 data=0x2d '-' (PC=0x00000028)
[11390000] UART WRITE: addr=0x10000000 data=0x56 'V' (PC=0x00000028)
[12310000] UART WRITE: addr=0x10000000 data=0x21 '!' (PC=0x00000028)
[13230000] UART WRITE: addr=0x10000000 data=0x0a '\n' (PC=0x00000028)
=== Simulation Complete ===
```

**What to look for:**
- `UART WRITE` messages showing ASCII characters 'H', 'e', 'l', 'l', 'o', etc.
- Program counter (PC) advancing through different addresses
- Register writes with correct data values

---

## Debugging

### View Waveforms

The simulation generates a VCD (Value Change Dump) file for detailed signal inspection:

```bash
gtkwave sim/waveforms/tb_soc.vcd
```

**Useful signals to observe:**
- `tb_soc.dut.u_cpu_core.pc` - Program counter
- `tb_soc.dut.u_cpu_core.state` - Current CPU state
- `tb_soc.dut.u_cpu_core.instruction` - Current instruction being executed
- `tb_soc.dut.u_cpu_core.u_register_file.registers[10]` - Register x10 (a0)
- `tb_soc.dut.u_simple_bus.uart_wdata` - Data being written to UART

### Check the Disassembly

See what the processor is supposed to be executing:

```bash
cat build/hello.dump
```

This shows the assembly code with addresses and machine code encoding.

### Common Issues

| Problem | Likely Cause | Solution |
|---------|--------------|----------|
| No output | Software not built | Run `make sw` before `make sim` |
| `$readmem file not found` | Missing `build/hello.hex` | Ensure `make sw` completed successfully |
| Simulation hangs | Infinite loop in program | Check waveforms for stuck PC |
| Wrong characters printed | Memory addressing bug | Verify address calculations in disassembly |

---

## Learning Resources

### Project Documentation
- **BLOG_POST.md** - Detailed writeup of the design journey and all eight bugs we fixed
- **PROJECT_SPEC.md** - Complete technical specification and phase-by-phase workflow
- **.silicogenrules** - Design methodology and best practices

### External Resources
- [RISC-V ISA Specification](https://riscv.org/specifications/) - The official instruction set manual
- [Verilator User Guide](https://verilator.org/guide/latest/) - Simulation tool documentation
- [Digital Design and Computer Architecture: RISC-V Edition](https://www.elsevier.com/books/digital-design-and-computer-architecture/harris/978-0-12-820064-3) - Excellent textbook
- [OpenSBI Documentation](https://github.com/riscv-software-src/opensbi) - Our eventual boot target

---

## Project Roadmap

### Phase 0: Environment Setup (Complete)
- Installed Verilator, RISC-V toolchain, build tools
- Created project directory structure

### Phase 1: Microarchitecture Definition (Complete)
- Designed 8-state CPU state machine
- Documented datapath, control signals, memory map
- Defined CSR requirements for OpenSBI

### Phase 2: RTL Implementation - Core (Complete)
- Implemented all RV32I instructions (2,246 lines of SystemVerilog)
- Created modular design: ALU, decoder, register file, CSRs, multiply/divide
- Verified code compiles cleanly with Verilator

### Phase 3: System Integration (Complete)
- Built SoC with CPU, RAM, UART, and bus arbiter
- Implemented memory-mapped I/O
- Created top-level integration

### Phase 4: Simulation & Initial Testing (Complete)
- Created Verilator testbench infrastructure
- Fixed 8 critical hardware bugs
- **Milestone achieved:** CPU successfully executes assembly and prints to UART

### Phase 5: Full ISA Verification (In Progress)
- Comprehensive testing of M-extension (multiply/divide)
- Implement and test A-extension (atomics)
- Create exhaustive instruction-level test suite

### Phase 6: Trap Handling & CSRs (Planned)
- Implement exception and interrupt handling
- Complete CSR file with all required registers
- Test privilege mode transitions (M-mode, S-mode, U-mode)

### Phase 7: OpenSBI Integration (Planned)
- Build OpenSBI firmware from source
- Create device tree describing our hardware
- Debug boot process until OpenSBI banner appears

### Phase 8: FPGA Implementation (Future)
- Synthesize design for physical FPGA board
- Add clock management and I/O constraints
- Boot OpenSBI on real hardware

---

## Contributing

This is an educational project, and contributions are welcome! Interesting areas to explore:

- **Performance:** Add caching, pipelining, or out-of-order execution
- **Features:** Implement more RISC-V extensions (F/D for floating-point, V for vectors)
- **Testing:** Write more comprehensive test programs
- **FPGA:** Port to specific FPGA boards (Xilinx Artix-7, Lattice iCE40, etc.)
- **Documentation:** Improve diagrams, add tutorials

---

## License

This project is open source. Check individual file headers for specific licensing information.

---

## Acknowledgments

- **RISC-V International** - For creating an open, extensible ISA
- **Verilator Team** - For an incredible open-source simulator
- **OpenSBI Maintainers** - For production-grade RISC-V firmware
- **Uros Popovic** - Whose [excellent article](https://popovicu.com/posts/risc-v-sbi-and-full-boot-process/) inspired this project

---

## Contact & Status

**Project Status:** Active Development  
**Current Phase:** 4 of 8 Complete  
**Last Updated:** 2026-02-26

For questions, suggestions, or collaboration opportunities, open an issue or reach out through the project repository.

---

**"From transistors to operating systems: building real processors, one instruction at a time."**
