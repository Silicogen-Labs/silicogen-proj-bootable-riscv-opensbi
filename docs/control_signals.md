# Control Signals Specification

## Overview

This document defines all control signals generated by the control unit (state machine) to coordinate datapath operations. The control unit decodes instructions and generates appropriate control signals for each pipeline stage.

## Control Signal Groups

### 1. Program Counter Control

#### `pc_write_enable`
- **Type**: 1-bit
- **Function**: Enable writing to PC register
- **Active**: High
- **Timing**: Asserted when PC should be updated

#### `pc_source[1:0]`
- **Type**: 2-bit
- **Function**: Select source for next PC value
- **Encoding**:
  - `2'b00`: PC + 4 (sequential execution)
  - `2'b01`: Branch target (PC + imm)
  - `2'b10`: Jump target (JAL: PC + imm, JALR: rs1 + imm)
  - `2'b11`: Trap vector (mtvec CSR value)

---

### 2. Instruction Register Control

#### `ir_write_enable`
- **Type**: 1-bit
- **Function**: Latch instruction from bus into IR
- **Active**: High
- **Timing**: Asserted in FETCH_WAIT state when bus_ready is high

---

### 3. Register File Control

#### `reg_write_enable`
- **Type**: 1-bit
- **Function**: Enable writing to register file
- **Active**: High
- **Timing**: Asserted in WRITEBACK state for instructions that write to rd
- **Note**: Writes to x0 are automatically ignored by register file

#### `reg_write_source[2:0]`
- **Type**: 3-bit
- **Function**: Select data source for register writeback
- **Encoding**:
  - `3'b000`: ALU result
  - `3'b001`: Memory read data (loads)
  - `3'b010`: PC + 4 (JAL/JALR)
  - `3'b011`: CSR read data
  - `3'b100`: Multiplier/Divider result
  - `3'b101`: Upper immediate (LUI)
  - `3'b110`: Reserved
  - `3'b111`: Reserved

---

### 4. ALU Control

#### `alu_op[3:0]`
- **Type**: 4-bit
- **Function**: Select ALU operation
- **Encoding**:
  - `4'b0000`: ADD
  - `4'b0001`: SUB
  - `4'b0010`: AND
  - `4'b0011`: OR
  - `4'b0100`: XOR
  - `4'b0101`: SLL (shift left logical)
  - `4'b0110`: SRL (shift right logical)
  - `4'b0111`: SRA (shift right arithmetic)
  - `4'b1000`: SLT (set less than, signed)
  - `4'b1001`: SLTU (set less than, unsigned)
  - `4'b1010`: Pass operand A (for LUI/AUIPC)
  - `4'b1011`: Pass operand B
  - `4'b1100-1111`: Reserved

#### `alu_src_a[1:0]`
- **Type**: 2-bit
- **Function**: Select first ALU operand
- **Encoding**:
  - `2'b00`: rs1_data (register file output)
  - `2'b01`: PC (for AUIPC, branches, jumps)
  - `2'b10`: Zero (for LUI)
  - `2'b11`: Reserved

#### `alu_src_b[1:0]`
- **Type**: 2-bit
- **Function**: Select second ALU operand
- **Encoding**:
  - `2'b00`: rs2_data (register file output)
  - `2'b01`: Immediate value
  - `2'b10`: Constant 4 (for PC + 4)
  - `2'b11`: Reserved

---

### 5. Memory Interface Control

#### `mem_read`
- **Type**: 1-bit
- **Function**: Assert memory read request
- **Active**: High
- **Timing**: Asserted in MEMORY state for load instructions

#### `mem_write`
- **Type**: 1-bit
- **Function**: Assert memory write request
- **Active**: High
- **Timing**: Asserted in MEMORY state for store instructions

#### `mem_width[1:0]`
- **Type**: 2-bit
- **Function**: Specify memory transaction width
- **Encoding**:
  - `2'b00`: Byte (8 bits)
  - `2'b01`: Half-word (16 bits)
  - `2'b10`: Word (32 bits)
  - `2'b11`: Reserved (future double-word)

#### `mem_unsigned`
- **Type**: 1-bit
- **Function**: Load data as unsigned (zero-extend instead of sign-extend)
- **Active**: High
- **Relevant For**: Load instructions (LBU, LHU)

#### `mem_addr_source`
- **Type**: 1-bit
- **Function**: Select memory address source
- **Encoding**:
  - `1'b0`: PC (instruction fetch)
  - `1'b1`: ALU result (data memory access)

---

### 6. Branch Control

#### `branch_op[2:0]`
- **Type**: 3-bit
- **Function**: Select branch condition
- **Encoding**:
  - `3'b000`: BEQ (equal)
  - `3'b001`: BNE (not equal)
  - `3'b010`: Reserved
  - `3'b011`: Reserved
  - `3'b100`: BLT (less than, signed)
  - `3'b101`: BGE (greater or equal, signed)
  - `3'b110`: BLTU (less than, unsigned)
  - `3'b111`: BGEU (greater or equal, unsigned)

#### `branch_enable`
- **Type**: 1-bit
- **Function**: Enable branch logic
- **Active**: High
- **Timing**: Asserted for branch instructions

---

### 7. Multiplier/Divider Control

#### `muldiv_op[2:0]`
- **Type**: 3-bit
- **Function**: Select multiply/divide operation
- **Encoding**:
  - `3'b000`: MUL (multiply, lower 32 bits)
  - `3'b001`: MULH (multiply high, signed × signed)
  - `3'b010`: MULHSU (multiply high, signed × unsigned)
  - `3'b011`: MULHU (multiply high, unsigned × unsigned)
  - `3'b100`: DIV (divide, signed)
  - `3'b101`: DIVU (divide, unsigned)
  - `3'b110`: REM (remainder, signed)
  - `3'b111`: REMU (remainder, unsigned)

#### `muldiv_start`
- **Type**: 1-bit
- **Function**: Start multiply/divide operation
- **Active**: High (pulse)
- **Timing**: Asserted for one cycle in EXECUTE state

#### `muldiv_busy`
- **Type**: 1-bit (input from muldiv unit)
- **Function**: Indicates operation in progress
- **Active**: High
- **Usage**: Stalls state machine in EXECUTE state

---

### 8. CSR Control

#### `csr_read_enable`
- **Type**: 1-bit
- **Function**: Enable CSR read
- **Active**: High

#### `csr_write_enable`
- **Type**: 1-bit
- **Function**: Enable CSR write
- **Active**: High

#### `csr_op[1:0]`
- **Type**: 2-bit
- **Function**: Select CSR operation
- **Encoding**:
  - `2'b00`: None (no CSR operation)
  - `2'b01`: RW (read/write)
  - `2'b10`: RS (read and set bits)
  - `2'b11`: RC (read and clear bits)

#### `csr_imm_mode`
- **Type**: 1-bit
- **Function**: Use immediate instead of rs1 for CSR operation
- **Active**: High
- **Relevant For**: CSRRWI, CSRRSI, CSRRCI

---

### 9. Atomic Operations Control

#### `atomic_op[4:0]`
- **Type**: 5-bit
- **Function**: Select atomic operation
- **Encoding** (from funct5):
  - `5'b00010`: LR.W (load reserved)
  - `5'b00011`: SC.W (store conditional)
  - `5'b00001`: AMOSWAP.W
  - `5'b00000`: AMOADD.W
  - `5'b00100`: AMOXOR.W
  - `5'b01100`: AMOAND.W
  - `5'b01000`: AMOOR.W
  - `5'b10000`: AMOMIN.W
  - `5'b10100`: AMOMAX.W
  - `5'b11000`: AMOMINU.W
  - `5'b11100`: AMOMAXU.W

#### `atomic_enable`
- **Type**: 1-bit
- **Function**: Enable atomic operation
- **Active**: High

---

### 10. Bus Interface Control

#### `bus_req`
- **Type**: 1-bit
- **Function**: Request bus transaction
- **Active**: High
- **Timing**: Asserted in FETCH and MEMORY states

#### `bus_we`
- **Type**: 1-bit
- **Function**: Bus write enable (0=read, 1=write)
- **Active**: High for writes

#### `bus_ready`
- **Type**: 1-bit (input from bus)
- **Function**: Bus transaction complete
- **Active**: High
- **Usage**: Controls state transitions from FETCH_WAIT and MEMORY_WAIT

---

### 11. Trap/Exception Control

#### `trap_enable`
- **Type**: 1-bit
- **Function**: Enter trap handler
- **Active**: High
- **Timing**: Asserted when exception or interrupt detected

#### `trap_cause[3:0]`
- **Type**: 4-bit
- **Function**: Exception cause code
- **Encoding**:
  - `4'h0`: Instruction address misaligned
  - `4'h1`: Instruction access fault
  - `4'h2`: Illegal instruction
  - `4'h3`: Breakpoint (EBREAK)
  - `4'h4`: Load address misaligned
  - `4'h5`: Load access fault
  - `4'h6`: Store/AMO address misaligned
  - `4'h7`: Store/AMO access fault
  - `4'h8`: Environment call from U-mode (ECALL) — **defined but unreachable** (M-mode only core)
  - `4'h9`: Environment call from S-mode — **defined but unreachable** (M-mode only core)
  - `4'hB`: Environment call from M-mode
  - `4'hC`: Instruction page fault
  - `4'hD`: Load page fault
  - `4'hF`: Store/AMO page fault

**Note**: `WFI` (Wait For Interrupt) and `SFENCE.VMA` are decoded but treated as NOPs in this M-mode-only core.

---

## Control Signal Truth Table (by Instruction Type)

### R-Type (e.g., ADD, SUB, AND, OR, XOR, SLT, SLTU, SLL, SRL, SRA)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b000` (ALU result) |
| `alu_src_a` | `2'b00` (rs1_data) |
| `alu_src_b` | `2'b00` (rs2_data) |
| `alu_op` | Depends on funct3/funct7 |
| `mem_read` | 0 |
| `mem_write` | 0 |

### I-Type Arithmetic (e.g., ADDI, ANDI, ORI, XORI, SLTI, SLTIU)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b000` (ALU result) |
| `alu_src_a` | `2'b00` (rs1_data) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | Depends on funct3 |
| `mem_read` | 0 |
| `mem_write` | 0 |

### Load (LB, LH, LW, LBU, LHU)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b001` (memory data) |
| `alu_src_a` | `2'b00` (rs1_data) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | `4'b0000` (ADD) |
| `mem_read` | 1 |
| `mem_write` | 0 |
| `mem_width` | Depends on funct3 |
| `mem_unsigned` | Depends on funct3 |
| `mem_addr_source` | `1'b1` (ALU result) |

### Store (SB, SH, SW)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in MEMORY_WAIT) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 0 |
| `alu_src_a` | `2'b00` (rs1_data) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | `4'b0000` (ADD) |
| `mem_read` | 0 |
| `mem_write` | 1 |
| `mem_width` | Depends on funct3 |
| `mem_addr_source` | `1'b1` (ALU result) |

### Branch (BEQ, BNE, BLT, BGE, BLTU, BGEU)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in EXECUTE) |
| `pc_source` | `2'b01` if taken, `2'b00` if not |
| `reg_write_enable` | 0 |
| `alu_src_a` | `2'b01` (PC) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | `4'b0000` (ADD for target calc) |
| `branch_enable` | 1 |
| `branch_op` | Depends on funct3 |
| `mem_read` | 0 |
| `mem_write` | 0 |

### JAL

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in EXECUTE) |
| `pc_source` | `2'b10` (jump target) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b010` (PC+4) |
| `alu_src_a` | `2'b01` (PC) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | `4'b0000` (ADD) |
| `mem_read` | 0 |
| `mem_write` | 0 |

### JALR

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in EXECUTE) |
| `pc_source` | `2'b10` (jump target) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b010` (PC+4) |
| `alu_src_a` | `2'b00` (rs1_data) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | `4'b0000` (ADD) |
| `mem_read` | 0 |
| `mem_write` | 0 |

### LUI

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b101` (upper immediate) |
| `mem_read` | 0 |
| `mem_write` | 0 |

### AUIPC

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b000` (ALU result) |
| `alu_src_a` | `2'b01` (PC) |
| `alu_src_b` | `2'b01` (immediate) |
| `alu_op` | `4'b0000` (ADD) |
| `mem_read` | 0 |
| `mem_write` | 0 |

### CSR Instructions (CSRRW, CSRRS, CSRRC, CSRRWI, CSRRSI, CSRRCI)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b011` (CSR data) |
| `csr_read_enable` | 1 |
| `csr_write_enable` | 1 (if rs1/imm ≠ 0 for RS/RC) |
| `csr_op` | Depends on funct3 |
| `csr_imm_mode` | Depends on funct3 |
| `mem_read` | 0 |
| `mem_write` | 0 |

### M-Extension (MUL, MULH, MULHU, MULHSU, DIV, DIVU, REM, REMU)

| Signal | Value |
|--------|-------|
| `pc_write_enable` | 1 (in WRITEBACK) |
| `pc_source` | `2'b00` (PC+4) |
| `reg_write_enable` | 1 |
| `reg_write_source` | `3'b100` (muldiv result) |
| `muldiv_start` | 1 (in EXECUTE entry) |
| `muldiv_op` | Depends on funct3 |
| `mem_read` | 0 |
| `mem_write` | 0 |

---

## State-Specific Control Signals

### RESET
- All control signals initialized to safe/inactive values
- `pc_write_enable` = 1 to load reset vector

### FETCH
- `bus_req` = 1
- `bus_we` = 0
- `mem_addr_source` = 0 (PC)

### FETCH_WAIT
- `ir_write_enable` = 1 when `bus_ready` = 1

### DECODE
- Control signals decoded from instruction
- No datapath modifications

### EXECUTE
- Control signals active based on instruction type
- PC updated for branches/jumps

### MEMORY
- `bus_req` = 1
- `mem_read` or `mem_write` = 1
- `mem_addr_source` = 1 (ALU result)

### MEMORY_WAIT
- Wait for `bus_ready`

### WRITEBACK
- `reg_write_enable` = 1 (if applicable)
- `pc_write_enable` = 1

### TRAP
- `trap_enable` = 1
- `pc_write_enable` = 1
- `pc_source` = `2'b11` (trap vector)
- CSR updates for mepc, mcause, mtval, mstatus

---

## Implementation Notes

1. **Default Values**: All control signals should have safe default values (typically 0) to prevent unintended operations
2. **Combinational Logic**: Control signals are generated combinationally from current state and instruction
3. **Critical Path**: Decoder → Control unit → Multiplexers is a critical timing path
4. **One-Hot Encoding**: Consider one-hot state encoding for faster decode
5. **Verification**: Each instruction should have a unique control signal pattern for verification

---

## Revision History

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-26 | Initial specification |
